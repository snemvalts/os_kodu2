{"version":3,"sources":["components/processinput/ProcessInput.tsx","components/memorydisplay/MemoryDisplay.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["ProcessInput","props","useState","processString","setProcessString","selectedProcess","setSelectedProcess","selectedAlgorithm","setSelectedAlgorithm","onRadioClick","event","target","value","onAlgorithmClick","onSubmit","onSubmitted","preventDefault","type","pattern","className","onChange","name","checked","MemoryDisplay","memoryTable","setMemoryTable","processColors","P0","P1","P2","P3","P4","P5","P6","P7","P8","P9","P10","useEffect","console","log","memory","header","rows","i","push","key","forEach","memoryRow","index","memoryTableCells","map","cell","cellIndex","processColor","filled","process","style","backgroundColor","border","exceptions","indexOf","colSpan","displayed","LastFit","size","lastFilled","every","length","free","j","undefined","BestFit","blocks","FindFreeBlocks","bestFitBlock","block","start","RandomFit","filter","Math","floor","random","WorstFit","worstFitBlock","searchingForEnd","blockStart","App","memoryString","setMemoryString","memoryAlgorithm","setMemoryAlgorithm","showMemory","setShowMemory","displayedMemory","setDisplayedMemory","exceptionRows","setExceptionRows","randomValue","setRandomValue","memoryStates","processes","parseMemoryString","emptyMemory","doesntFit","duration","startingPoint","findStartingPoint","split","token","number","parseInt","algorithm","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.6f1ca7a5.chunk.js","sourcesContent":["import React, {ChangeEvent, FormEvent} from 'react';\nimport { FunctionComponent, useState } from 'react';\nimport './ProcessInput.css';\nimport { MemoryAlgorithm } from \"../../App\";\n\nconst ProcessInput: FunctionComponent<\n  {\n    onSubmitted: (process: string, type: MemoryAlgorithm) => void\n  }> = (props) => {\n\n  const [processString, setProcessString] = useState('');\n  const [selectedProcess, setSelectedProcess] = useState<'1' | '2' | '3' | ''>('');\n  const [selectedAlgorithm, setSelectedAlgorithm] = useState<MemoryAlgorithm>('last-fit');\n\n\n  const onInput = (event: ChangeEvent) => {\n    setSelectedProcess('');\n    setProcessString((event.target as HTMLInputElement).value);\n  };\n\n  const onRadioClick = (event: ChangeEvent) => {\n    const values = {\n      '1': '1,8;7,4;10,6;25,2;1,4;13,3;6,2;8,1;50,1',\n      '2': '1,8;35,4;3,6;4,2;1,4;3,3;1,2;5,1;50,1',\n      '3': '1,8;7,4;10,6;25,2;1,4;13,3;6,2;8,2;20,1',\n    };\n\n    setSelectedProcess(((event.target as HTMLInputElement).value as '1' | '2' | '3'));\n    setProcessString(values[((event.target as HTMLInputElement).value as '1' | '2' | '3')]);\n  };\n\n  const onAlgorithmClick = (event: ChangeEvent) => {\n    setSelectedAlgorithm((event.target as HTMLInputElement).value as MemoryAlgorithm);\n  };\n\n  const onSubmit = (event: FormEvent) => {\n    props.onSubmitted(processString, selectedAlgorithm);\n    event.preventDefault();\n  };\n\n\n  return (\n    <form onSubmit={onSubmit}>\n      <h1>OS kodutöö 2, mäluhõivamisalgoritmide visualisatsioon</h1>\n      <h5>Sander Nemvalts</h5>\n      <h2>Testmuster: </h2>\n      <input type=\"text\"\n             pattern=\"^((\\d+,\\d+;?){1,12})$\"\n             value={processString}\n             className='pattern-input'\n             onChange={onInput}/>\n\n      <div className=\"radio-container\">\n        <div>\n          <label>\n          <input type=\"radio\"\n                 value='1'\n                 name='first'\n                 checked={selectedProcess === '1'}\n                 onChange={onRadioClick}/>\n          Esimene näidismuster</label>\n        </div>\n        <div>\n          <label>\n          <input type=\"radio\"\n                 value='2'\n                 name='second'\n                 checked={selectedProcess === '2'}\n\n                 onChange={onRadioClick}/>\n          Teine näidismuster</label>\n        </div>\n        <div>\n          <label>\n          <input type=\"radio\"\n                 value='3'\n                 name='third'\n                 checked={selectedProcess === '3'}\n                 onChange={onRadioClick}/>\n          Kolmas näidismuster\n          </label>\n        </div>\n      </div>\n\n      <div className=\"radio-container\">\n        <div>\n          <label>\n            <input type=\"radio\"\n                   value='last-fit'\n                   name='last-fit'\n                   checked={selectedAlgorithm === 'last-fit'}\n                   onChange={onAlgorithmClick}/>\n            last-fit</label>\n        </div>\n        <div>\n          <label>\n            <input type=\"radio\"\n                   value='best-fit'\n                   name='best-fit'\n                   checked={selectedAlgorithm === 'best-fit'}\n                   onChange={onAlgorithmClick}/>\n            best-fit</label>\n        </div>\n        <div>\n          <label>\n            <input type=\"radio\"\n                   value='worst-fit'\n                   name='worst-fit'\n                   checked={selectedAlgorithm === 'worst-fit'}\n                   onChange={onAlgorithmClick}/>\n            worst-fit</label>\n        </div>\n        <div>\n          <label>\n            <input type=\"radio\"\n                   value='random-fit'\n                   name='random-fit'\n                   checked={selectedAlgorithm === 'random-fit'}\n                   onChange={onAlgorithmClick}/>\n            random-fit</label>\n        </div>\n      </div>\n\n      <button type=\"submit\">Näita mälu visualisatsiooni</button>\n    </form>\n  )\n};\n\nexport default ProcessInput;\n","import React, {useState, useEffect} from 'react';\nimport ProcessInput, {MemoryCell, MemoryState} from '../../App';\nimport './MemoryDisplay.css';\nconst MemoryDisplay: React.FC<{memory: MemoryState[], displayed: boolean, exceptions: number[]}> = (props) => {\n\n  const [memoryTable, setMemoryTable] = useState();\n\n  const processColors: { [key:string]: string} = {\n    P0: '#5C6BC0',\n    P1: '#FFEE58',\n    P2: '#F48FB1',\n    P3: '#9575CD',\n    P4: '#42A5F5',\n    P5: '#26A69A',\n    P6: '#FF9800',\n    P7: '#90A4AE',\n    P8: '#8D6E63',\n    P9: '#D4E157',\n    P10: '#FFCA28',\n  };\n\n  useEffect(() => {\n    console.log('memory display', props.memory);\n    const header: JSX.Element[] = [<th></th>];\n    const rows: JSX.Element[] = [];\n\n    for(let i = 0; i < 50; i++) {\n      header.push((<th key={`headercell${i}`}>{i}</th>))\n    }\n\n    props.memory.forEach((memoryRow: MemoryState, index) => {\n      const memoryTableCells = memoryRow.map((cell: MemoryCell, cellIndex) => {\n        let processColor;\n        if (!cell.filled) {\n          processColor = 'white';\n        } else {\n          if (cell.process && processColors[cell.process]) {\n            processColor = processColors[cell.process];\n          } else {\n            processColor = 'red';\n          }\n        }\n        return (<td key={`cell${cellIndex}:${index}`} style={{backgroundColor: processColor, border: '1px solid black'}}>{cell.process}</td>)\n      });\n\n      if (props.exceptions.indexOf(index) > -1) {\n        rows.push(\n          <tr><td>{index}</td><td colSpan={50}>Ei suutnud mahutada!!</td></tr>\n        )\n      } else {\n        rows.push(\n          <tr><td>{index}</td>{memoryTableCells}</tr>\n        )\n      }\n    });\n\n    setMemoryTable(\n      <table>\n        <thead><tr>{header}</tr></thead>\n        <tbody>{rows}</tbody>\n      </table>\n    );\n\n  }, [props.memory]);\n\n  return (\n    <div className=\"MemoryDisplay\">\n      {props.displayed ? memoryTable : <span>mälutabel ilmub siia</span>}\n    </div>\n  );\n};\n\n\nexport default MemoryDisplay\n","import React, {useEffect, useState} from 'react';\nimport './App.css';\nimport ProcessInput from './components/processinput/ProcessInput';\nimport MemoryDisplay from './components/memorydisplay/MemoryDisplay';\n\nconst App: React.FC = () => {\n  const [memoryString, setMemoryString] = useState('');\n  const [memoryAlgorithm, setMemoryAlgorithm] = useState<MemoryAlgorithm | null>(null);\n  const [showMemory, setShowMemory] = useState(false);\n  const [displayedMemory, setDisplayedMemory] = useState<MemoryState[]>([[]]);\n  const [exceptionRows, setExceptionRows] = useState<number[]>([]);\n  const [randomValue, setRandomValue] = useState<number>();\n\n  const handleSubmit = (memoryString: string, algorithm: MemoryAlgorithm) => {\n    setMemoryString(memoryString);\n    setMemoryAlgorithm(algorithm);\n    setRandomValue(Math.random());\n    setShowMemory(true);\n  };\n\n\n\n\n  useEffect(() => {\n    const memoryStates: MemoryState[] = [];\n    const exceptionRows: number[] = [];\n    const processes = parseMemoryString(memoryString);\n\n\n    for (let i = 0; i < 10; i++) {\n      let emptyMemory: MemoryCell[] = [];\n      for (let i = 0; i < 50; i++) {\n        emptyMemory.push({\n          filled: false,\n          process: '-'\n        })\n      }\n      memoryStates.push(emptyMemory);\n    }\n\n    let currentTime = 0;\n\n\n    let doesntFit = false;\n\n    processes.forEach((process, index) => {\n      if (doesntFit) {\n        return;\n      }\n\n      let memory = memoryStates[index];\n      console.log(`memory #${index}`, [...memory]);\n      console.log('free blocks', FindFreeBlocks(memory));\n\n      const size = process[0];\n      const duration = process[1];\n\n      const startingPoint = findStartingPoint(memory, size, memoryAlgorithm);\n      if (startingPoint === -1) {\n        exceptionRows.push(index);\n        doesntFit = true;\n      } else if (index + duration > 10) {\n        exceptionRows.push(index);\n        doesntFit = true;\n      } else {\n        // ketrame läbi kõik stated\n        for(let j = index; j < index+duration; j++) {\n          // ja täidame need kohad ära protsessi mäluga\n          for(let i = startingPoint; i < startingPoint + size; i++) {\n            memoryStates[j][i] = {\n              filled: true,\n              process: `P${index}`,\n            }\n          }\n        }\n      }\n    });\n\n    setDisplayedMemory(memoryStates);\n    setExceptionRows(exceptionRows);\n  }, [memoryString, memoryAlgorithm, randomValue]);\n\n\n  const parseMemoryString = (memoryString: string) => {\n    return memoryString.split(';').map((token) => token.split(',').map(number => parseInt(number)));\n  };\n\n  const findStartingPoint = (memory: MemoryState, size: number, algorithm: MemoryAlgorithm | null) => {\n    if (algorithm === 'last-fit') {\n      return LastFit(memory, size);\n    }\n\n    if (algorithm === 'best-fit') {\n      return BestFit(memory, size);\n    }\n\n    if (algorithm === 'random-fit') {\n      return RandomFit(memory, size);\n    }\n\n    if (algorithm === 'worst-fit') {\n      return WorstFit(memory, size);\n    }\n\n    return -1;\n  };\n\n  return (\n    <div className=\"App\">\n      <ProcessInput onSubmitted={handleSubmit}/>\n      <MemoryDisplay displayed={showMemory} memory={displayedMemory} exceptions={exceptionRows}/>\n    </div>\n  );\n};\n\n\nconst LastFit = (memory: MemoryState, size: number) => {\n  let lastFilled = -1;\n\n  if (memory.every(cell => !cell.filled)) {\n    if (memory.length >= size) {\n      return 0;\n    }\n  }\n\n  for(let i = 0; i < memory.length; i++) {\n    if (memory[i - 1] && memory[i - 1].filled && !memory[i].filled) {\n      let free = true;\n      for (let j = i; j < i + size; j++) {\n        if (memory[j] === undefined) {\n          free = false;\n          break;\n        }\n\n        if (memory[j].filled) {\n          free = false;\n        }\n      }\n\n\n      if (free) {\n        lastFilled = i;\n      }\n    }\n  }\n\n  return lastFilled;\n};\n\n\nconst BestFit = (memory: MemoryState, size: number) => {\n  const blocks = FindFreeBlocks(memory);\n\n  let bestFitBlock: FreeBlock | null = null;\n\n  blocks.forEach((block: FreeBlock) => {\n    if (size <= block.size) {\n      if (bestFitBlock === null) {\n        bestFitBlock = block;\n      } else if (bestFitBlock !== null && block.size < bestFitBlock.size) {\n        bestFitBlock = block;\n      }\n    }\n  });\n\n  if (bestFitBlock === null) {\n    return -1;\n  } else {\n    // @ts-ignore\n    return bestFitBlock.start;\n  }\n\n};\n\nconst RandomFit = (memory: MemoryState, size: number) => {\n  const blocks = FindFreeBlocks(memory).filter(block => size <= block.size);\n\n  if (blocks.length === 0) {\n    return -1;\n  }\n\n  return blocks[Math.floor(Math.random()*blocks.length)].start;\n};\n\nconst WorstFit = (memory: MemoryState, size: number) => {\n  const blocks = FindFreeBlocks(memory).filter(block => size <= block.size);\n\n  let worstFitBlock: FreeBlock | null = null;\n\n  blocks.forEach((block: FreeBlock) => {\n    if (size <= block.size) {\n      if (worstFitBlock === null) {\n        worstFitBlock = block;\n      } else if (worstFitBlock !== null && block.size > worstFitBlock.size) {\n        worstFitBlock = block;\n      }\n    }\n  });\n\n  if (worstFitBlock === null) {\n    return -1;\n  } else {\n    // @ts-ignore\n    return worstFitBlock.start;\n  }\n};\n\n\nconst FindFreeBlocks = (memory: MemoryState): FreeBlock[] => {\n  const blocks: FreeBlock[] = [];\n\n  let searchingForEnd = false;\n  let blockStart = 0;\n\n  for(let i = 0; i < memory.length; i++) {\n    if (!memory[i].filled && !searchingForEnd) {\n      searchingForEnd = true;\n      blockStart = i;\n    }\n\n    if (memory[i].filled && searchingForEnd) {\n      blocks.push({\n        start: blockStart,\n        size: i - blockStart,\n      });\n      searchingForEnd = false;\n      blockStart = -1;\n    }\n  }\n\n  if (searchingForEnd) {\n    blocks.push({\n      start: blockStart,\n      size: memory.length - blockStart,\n    });\n  }\n\n  return blocks;\n}\n\nexport default App;\nexport type MemoryAlgorithm = 'last-fit' | 'best-fit' | 'worst-fit' | 'random-fit';\n\nexport type MemoryState = MemoryCell[];\n\nexport interface MemoryCell {\n  filled: boolean;\n  process?: string;\n  wontfit?: boolean;\n}\n\nexport interface FreeBlock {\n  start: number;\n  size: number;\n}","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}